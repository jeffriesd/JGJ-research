% For double-blind review submission, w/o CCS and ACM Reference (max
% submission space)
\documentclass[acmsmall,screen,review,anonymous]{acmart}
\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For double-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true}
%% For single-blind review submission, w/o CCS and ACM Reference (max submission space)
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}
%% For single-blind review submission, w/ CCS and ACM Reference
%\documentclass[acmsmall,review]{acmart}\settopmatter{printfolios=true}
%% For final camera-ready submission, w/ required CCS and ACM Reference
%\documentclass[acmsmall]{acmart}\settopmatter{}


%% Journal information
%% Supplied to authors by publisher for camera-ready submission;
%% use defaults for review submission.
\acmJournal{PACMPL}
\acmVolume{1}
\acmNumber{POPL} % CONF = POPL or ICFP or OOPSLA
\acmArticle{1}
\acmYear{2021}
\acmMonth{1}
\acmDOI{} % \acmDOI{10.1145/nnnnnnn.nnnnnnn}
\startPage{1}

%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission;
%% use 'none' for review submission.
\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
%\setcopyright{rightsretained}
%\copyrightyear{2018}           %% If different from \acmYear

%% Bibliography style
\bibliographystyle{ACM-Reference-Format}
%% Citation style
%% Note: author/year citations are required for papers published as an
%% issue of PACMPL.
\citestyle{acmauthoryear}   %% For author/year citations
%\citestyle{acmnumeric}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Note: Authors migrating a paper from PACMPL format to traditional
%% SIGPLAN proceedings format must update the '\documentclass' and
%% topmatter commands above; see 'acmart-sigplanproc-template.tex'.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



\usepackage[utf8]{inputenc}
\usepackage{ccicons}
\usepackage{verbatim}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amscd}
%\usepackage{MnSymbol}
\usepackage{xcolor}

\usepackage{bbold}
\usepackage{url}
\usepackage{upgreek}
%\usepackage{stmaryrd}

\usepackage{lipsum}
\usepackage{tikz-cd}
\usetikzlibrary{cd}
\usetikzlibrary{calc}
\usetikzlibrary{arrows}

\usepackage{bussproofs}
\EnableBpAbbreviations

\input{macros}
\input{mytheorem}

\theoremstyle{definition}
\newtheorem{exmpl}{Example}

\renewcommand{\greyout}[1]{}

\newcommand{\new}[1]{{\color{blue} {#1}}}


\newcommand{\emptyfun}{{[]}}
\newcommand{\cal}{\mathcal}
\newcommand{\F}{\mathcal{F}}
\renewcommand{\G}{\mathcal{G}}
\newcommand{\N}{\mathcal{N}}
\newcommand{\E}{\mathcal{E}}
\newcommand{\B}{\mathcal{B}}
\renewcommand{\P}{\mathcal{A}}
\newcommand{\pred}{\mathsf{Fam}}
\newcommand{\env}{\mathsf{Env}}
\newcommand{\set}{\mathsf{Set}}
\renewcommand{\S}{\mathcal S}
\renewcommand{\C}{\mathcal{C}}
\newcommand{\D}{\mathcal{D}}
\newcommand{\A}{\mathcal{A}}
\renewcommand{\id}{\mathit{id}}
\newcommand{\map}{\mathsf{map}}
\newcommand{\pid}{\underline{\mathit{id}}}
\newcommand{\pcirc}{\,\underline{\circ}\,}
\newcommand{\pzero}{\underline{0}}
\newcommand{\pone}{\underline{1}}
\newcommand{\psum}{\,\underline{+}\,}
\newcommand{\pinl}{\underline{\mathit{inL}}\,}
\newcommand{\pinr}{\underline{\mathit{inR}}\,}
\newcommand{\ptimes}{\,\underline{\times}\,}
\newcommand{\ppi}{\underline{\pi_1}}
\newcommand{\pppi}{\underline{\pi_2}}
\newcommand{\pmu}{\underline{\mu}}
\newcommand{\semmap}{\mathit{map}}
\newcommand{\subst}{\mathit{subst}}

\newcommand{\tb}[1]{~~ \mbox{#1} ~~}
\newcommand{\listt}[1]{(\mu \phi. \lambda \beta . \onet + \beta \times
  \phi \beta) #1} 
\newcommand{\filtype}{\Nat^\emptyset 
 (\Nat^\emptyset \, \alpha \, \mathit{Bool})\, (\Nat^\emptyset 
  (List \, \alpha) \, (List \, \alpha))} 
\newcommand{\filtypeGRose}{\Nat^\emptyset 
 (\Nat^\emptyset \, \alpha \, \mathit{Bool})\, (\Nat^\emptyset 
  (\mathit{GRose}\,\psi \, \alpha) \, (\mathit{GRose}\,\psi \, (\alpha
  + \onet)))} 
\newcommand{\maplist}{\mathit{map}_{\lambda A. \setsem{\emptyset; \alpha
      \vdash \mathit{List} \, \alpha} \rho[\alpha := A]}} 
\newcommand{\PLeaves}{\mathsf{PLeaves}}
\newcommand{\swap}{\mathsf{swap}}
\newcommand{\reverse}{\mathsf{reverse}}
\newcommand{\Bcons}{\mathit{Bcons}}
\newcommand{\Bnil}{\mathit{Bnil}}

\title[Parametricity Consequences of GADTs
  Representations]{Parametricity Consequences of GADTs
  Representations}

\author{Patricia Johann, Enrico Ghiorzi, and Daniel Jeffries}
\affiliation{ \institution{Appalachian State University}}
\email{johannp@appstate.edu, ghiorzie@appstate.edu,
  jeffriesd@appstate.edu}

\begin{document}

\begin{abstract}
{\color{red} FIX ME!} GADTs are misnamed. They don't really generalize
ADTs. And they don't behave the way we expect data types to behave. In
particular, they force us to choose between the naturality properties
we expect of their fmap functions and other parametricity results for
them, causing us to question in what sense GADTs are data types, and
what the value of the parametricity results for them as determined by
their syntax really is.
\end{abstract}

\maketitle

\section{Introduction}\label{sec:intro}
{\color{blue} map vs. fmap throughout.} {\color{blue} Add polynomial
  throughout?}

There are two standard ways to represent data types when studying
modern functional languages: via their Church encodings in a (possibly
higher-kinded) extension of System F~\cite{gir72}, the calculus at the
core of all such languages, and by augmenting System F
%a Hindley-Milner style calculus
with primitives for constructing them directly as fixpoints.
%{\color{blue} Something about when each of these representations is
%  used. The former perhaps more closely represents how data types are
%  represented in implementations, but the latter are how they have
%  heretofore primarily been treated theoretically.}
In models that validate the program optimization known as {\em short
  cut fusion}~\cite{glp93} the two representations are, in fact,
semantically equivalent, i.e., both have the same interpretation in
the model. Models in which the Church encodings and primitive
representations of all algebraic data types (ADTs) are semantically
equivalent include the operationally-based model of~\cite{pit98,pit00}
and the categorical models of~\cite{joh02,joh03}.
%\footnote{{\color{blue} Pitts proves the isomorphism only for
%    polynomial ADTs, whereas Johann {\em et al.}  prove it for any
%    data type that is the fixpoint of a first-order functor.}}
Correctness of short cut fusion, and thus semantic equivalence of
Church encodings and primitive representations, was recently extended
to the class of what might be called ``hereditarily polynomial''
{\color{blue} to include truly nested such types} nested types via the
categorical model of~\cite{jgj21}. But, as shown in
Section~\ref{sec:par} below, for some GADTs --- even polynomial ones
--- no such isomorphism holds.

GADTs are traditionally represented via Church encodings. In this
view, GADTs are completely determined by their syntax; for example,
the GADT $\mathsf{Seq}$ defined in Haskell by
\begin{equation}\label{eq:seq}
\begin{array}{l}
\mathsf{data\, Seq\,a\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Const ::\, a \to Seq\,a}\\
\mathsf{\;\;\;\;\;\;\;\;Pair\,\,\,\,\, ::\, Seq \,a \to Seq\,b \to
  Seq\,(a \times b)}\\ 
\end{array}
\end{equation}
\noindent
comprises sequences of any type $\mathsf{a}$ and sequences obtained by
pairing the data in two already existing sequences. By contrast, the
primitive representation sees a GADT as the {\em functorial
  completion}~\cite{jp19} of its syntax. Completing a GADT's syntax to
a {\em functor} is necessary in order to be able to take the least
fixed point~\cite{tfca}, so it is inherent in the view of data types
as their primitive representations. Viewed as its primitive
representation, $\mathsf{Seq}$ comprises not just those data elements
representable in syntax, but also all data elements of the form
$\mathsf{map\,f\,s}$ for all types $\mathsf{t_1}$ and $\mathsf{t_2}$,
all functions $\mathsf{f : t_1 \to t_2}$ definable in the language,
and all $\mathsf{s :: Seq\,t_1}$, as well as all data elements of the
form $\mathsf{map\,g\,s'}$ for each appropriately typed function
$\mathsf{g}$ and each element $\mathsf{s'}$ already added to the data
type, and so on. Functorial completion for $\mathsf{Seq}$ adds, in
particular, data elements of the form
$\mathsf{map\,g\,(Pair\,u_1\,u_2)}$ even though these may not
themselves be of the form $\mathsf{Pair\,v_1\,v_2}$ for any terms
$\mathsf{v_1}$ and $\mathsf{v_2}$. By contrast, functorial completion
adds no new data elements to the syntax of a GADT that is actually a
(polynomial) ADT or a (hereditarily polynomial) nested type, so its
Church encoding and primitive representation coincide. However, these
representations are rarely the same for GADTs.

But does it really matter which way we view GADTs?

A GADT programmer is likely to use GADTs precisely {\em because} they
exhibit different behaviors at different types, and thus to consider a
GADT to be completely specified by its syntax. When used this way, the
shape of a particular element of a GADTs is actually {\em determined}
by the data it contains. As a result, it is not expected to support a
$\mathsf{map}$ function --- i.e., to be an instance of Haskell's
$\mathsf{Functor}$ class --- like other data types. Indeed, the
definition for $\mathsf{Seq}$ above specifies that an element of the
form $\mathsf{Pair\,u_1\,u_2}$ must have the shape of a sequence of
data of pair type rather than a sequence of data of arbitrary type
$\mathsf{e}$.  The clause of $\mathsf{map}$ for the $\mathsf{Pair}$
constructor should therefore feed $\mathsf{map}$ a function $\mathsf{f
  :: (a \times b) \to e}$ and a term of the form $\mathsf{Pair
  \,u_1\,u_2}$ for $\mathsf{u_1 :: Seq\,a}$ and $\mathsf{u_2 ::
  Seq\,b}$, and produce a term $\mathsf{Pair\,v_1\,v_2}$ for some
appropriately typed terms $\mathsf{v_1}$ and $\mathsf{v_2}$. However,
it is not clear how to achieve this since $\mathsf{e}$ need not
necessarily be a product type. And even if $\mathsf{e}$ {\em were}
known to be of the form $\mathsf{w \times z}$, then we still wouldn't
necessarily have a way to produce data of type $\mathsf{w \times z}$
from only $\mathsf{f :: a \times b \to w \times z}$ and $\mathsf{u_1}$
and $\mathsf{u_2}$ unless we knew, e.g., that $\mathsf{f}$ was a pair
of functions $\mathsf{(f_1 :: a \to w, f_2 :: b \to z)}$. When it is
intended to capture this kind of non-uniform behavior, a GADT's
behavior does not generalize that of ADTs as advertised, and the GADT
doesn't even really behave like a traditional data type. In this
situation, the GADT cannot be seen as the least fixpoint of a functor,
and must instead be represented via its Church encoding.

A semanticist, on the other hand, is likely to follow~\cite{bfss90}
and expect GADTs to behave as their names suggests --- i.e., as
generalizations of ADTs. The semanticist is thus likely to expect a
GADT to be able to be used as a ADT is used --- i.e., as a shape
filled with data that can be changed without also changing the
shape. To be used in this way, a GADT must be viewed in terms of its
primitive representation. In fact, the functorial completion of a GADT
inherent in its primitive representation is exactly what is needed to
ensure that the GADT supports a $\mathsf{map}$ function, i.e., is
interpreted as a true categorical functor, and can therefore be made
an instance of Haskell's $\mathsf{Functor}$ class. It is worth noting,
however, that since the functorial completion of a GADT includes only
those data elements that are derivable via repeated applications of
$\mathsf{map}$ starting from those specified by its syntax, primitive
GADTs need not, in general, be nested types. For example, the
functorial completion of the GADT $\mathsf{G}$ defined by
\begin{equation}\label{eq:G}
\begin{array}{l}
\mathsf{data\,G\,a\,where}\\
\mathsf{\;\;\;\;\;\;\;\;c : G\,1}
\end{array}
\end{equation}
{\color{blue} Use $\top$ instead of $1$ throughout?} includes elements
at any instance $\mathsf{G\,a}$ for any type $\mathsf{a} \not =
\mathsf{0}$ since there is always a function from $\mathsf{1}$ to such
an $\mathsf{a}$, but does not include any terms at instance
$\mathsf{G\,0}$. Indeed, $\mathsf{G\,0}$ is not inhabited via the
syntactic specifiation of $\mathsf{G}$, and is not inhabited via
functorial completion because it is not possible to define a function
from $\mathsf{1}$ into $\mathsf{0}$. {\color{blue} Use $\bot$ instead
  of $0$ here?}

The key observation of this paper is that, while the viewpoints of
both the GADT programmer and the semanticist are both valid, the two
are irreconcilable. Importantly, which point of view is adopted in any
particular setting has deep consequences for the ways GADTs can be
used and reasoned about there. In this paper we show that the choice
of GADT representation has deep implications for parametric reasoning
about structures of those types. In particular, a GADT programmer who
views GADTs as their Church encodings cannot safely use program
transformations or reasoning principles for them that involve
$\mathsf{map}$ functions for them, although they may be able to
program with and reason about GADTs using other consequences of
parametricity, such as type inhabitation results. On the other hand, a
semanticist who views GADTs as primitive data types will have all
naturality-based program transformations and reasoning principles for
GADTs at their disposal, but, since no parametric model can be
constructed for primitive GADTs, non-naturality consequences of
parametric reasoning may not be available to them.

Below we show how the above observations can be made precise, thereby
answering the question we posed above in the affirmative: Yes, it
really does matter which way we view GADTs.

\section{Representations of Algebraic Data Types}\label{sec:adts}

A (polynomial) {\em algebraic data type} (ADT) has the form
\[\mathsf{T\,a} = \mathsf{c_1 t_{11}}...\mathsf{t_{1k_1}}\, |\, ...\, |\,
\mathsf{c_n t_{n1}}...\mathsf{t_{nk_n}}\] where each $\mathsf{t_{ij}}$
is a type also depending only on $\mathsf{a}$. Such a data type can be
thought of as a ``container'' for data of type $\mathsf{a}$. The data
in an ADT are arranged at various {\em positions} in its underlying
{\em shape}, which is determined by the types of its {\em
  constructors} $\mathsf{c_1},...,\mathsf{c_n}$. An ADT's constructors
are used to build the data values of the data type, as well as to
analyze those values using {\em pattern matching}. ADTs are used
extensively in functional programming to structure computations, to
express invariants of the data over which computations are defined,
and to ensure the type safety of programs specifying those
computations.

List types are the quintessential examples of ADTs. The shape of the
container underlying the list type
\[\mathsf{List\,a} = \mathsf{Nil} \,|\, \mathsf{Cons\,a\,(List\,a)}\]
is determined by the types of its two constructors $\mathsf{Nil\, ::\,
  List\, a}$ and $\mathsf{Cons \,::\,a \to \List\,a\to
  List\,a}$. These constructors specify that the data in a list of
type $\mathsf{List\,a}$ are arranged linearly. The shape underlying
the type $\mathsf{List\,a}$ is therefore given by the set $\nat$ of
natural numbers, with each natural number representing a choice of
length for a list structure, and the positions in a structure of shape
$\mathsf{n}$ are given by natural numbers ranging from $\mathsf{0}$ to
$\mathsf{n-1}$. Since the type argument to every occurrence of the
type constructor $\mathsf{List}$ in the right-hand side of above
definition is the same the type instance being defined on its
left-hand side, the type $\mathsf{List\,a}$ enforces the invariant
that all of the data in a structure of this type have the same type
$\mathsf{a}$. In a similar way, the tree type
\[\mathsf{Tree\, a} = \mathsf{Leaf\,a}
\,|\,\mathsf{Node\,(Tree\,a)\,a\,(Tree\,a)}\] of binary trees has as
its underlying shape the type of binary trees of units, and the
positions in a structure of this type are given by sequences of L (for
``left'') and R (for ``right'') navigating a path through the
structure. The type $\mathsf{Tree\, a}$ enforces the invariant that
all of the data at the nodes and leaves in a structure of this type
have the same type $\mathsf{a}$.

Since the shape of an ADT structure --- i.e., a structure whose type
is an instance of an ADT --- is independent of the type of data it
contains, ADTs can be defined polymorphically. As a result, an ADT
structure containing data of type $\mathsf{a}$ can be transformed into
another ADT structure of the exact same shape containing data of
another type $\mathsf{b}$ simply by applying a given function
$\mathsf{f \,:\,a \to b}$ to each of its elements. Indeed, every ADT
$\mathsf{T}$ can be made an instance of Haskell's $\mathsf{Functor}$
class by defining a type-and-data-uniform, structure-preserving,
data-changing $\mathsf{fmap_T}$ function for it.  Moreover, given a
type-independent way of rearranging an ADT structure's shape
$\mathsf{T\,a}$ into the shape for another ADT structure
$\mathsf{T'\,a}$, we get the same structure of type $\mathsf{T'\,b}$
regardless of whether we first rearrange the original structure of
type $\mathsf{T\,a}$ into one of type $\mathsf{T'\,a}$ and then use
$\mathsf{fmap_{T'}}$ to convert that resulting structure to one of
type $\mathsf{T'\,b}$, or we first use $\mathsf{fmap_T}$ to convert
the original structure of type $\mathsf{T\,a}$ to one of type
$\mathsf{T\,b}$ and then rearrange that resulting structure into one
of type $\mathsf{T'\,b}$. For example, if $\mathsf{f : a \to b}$,
$\mathsf{xs \,:\,List\,a}$, and $\mathsf{g : List\,a\to Tree\,a}$
arranges lists into trees in a type-independent way, then we have the
following rearrange-transform property:
\[\mathsf{fmap_{Tree}\,f\,(g \, xs) \,=\, g\,(fmap_{List}\,f\,xs)}\]

\subsection{Church Encodings of ADTs}

One way to represent ADTs is via their Church encodings. A Church
encoding is a representation of a data type as a function in a pure
lambda calculus, such as System F and its higher-kinded
extensions. They, together with other related encodings, have recently
been popularized as various {\em visitor patterns} in object-oriented
programming~\cite{owg08,gon21}.

Church encodings of ADTs can be defined in any language that supports
functions. They can therefore be used to represent ADTs in languages
that do not support primitives for sum types, product types, or
recursion. The Church encodings of the ADTs $\mathsf{List\,a}$ and
$\mathsf{Tree\,a}$, for example, are
\[\mathsf{List\,a} = \mathsf{\forall b.\,b \to (a \to b \to b) \to b}\]
and 
\[\mathsf{Tree\,a} = \mathsf{\forall b.\,(a \to b) \to (b \to a \to b
  \to b) \to b}\] respectively. The argument types are abstractions of
the types of ADTs' constructors. For instance, $\mathsf{b}$ abstracts
the type $\mathsf{List\,a}$ of the constructor $\mathsf{Nil}$ for
lists, and $\mathsf{a \to b \to b}$ abstracts the type $\mathsf{a \to
  List\,a \to List\,a}$ of the constructor $\mathsf{Cons}$.

Because the types of the ``abstract constructors'' for an ADT are
uniform in their argument types, it is always possible to Church
encode the type constructors themselves as well. For example, the
Church encodings of the type constructors $\mathsf{List}$ and
$\mathsf{Tree}$ are
\[\mathsf{List} = \mathsf{\forall a. \forall b.\,b \to (a \to b \to b)
  \to b}\] 
and 
\[\mathsf{Tree} = \mathsf{\forall a. \forall b.\,(a \to b) \to (b \to
  a \to b \to b) \to b}\] respectively. This is what allows an ADT's
associated type constructor to be made an instance of Haskell's
$\mathsf{Functor}$ class. For example, Haskell's built-in
$\mathsf{map}$ function makes the type constructor $\mathsf{List}$ an
instance of the $\mathsf{Functor}$ class, and for $\mathsf{Tree}$ we
can define
\[\begin{array}{lll}
\mathsf{map_{Tree}} & \mathsf{::} & \mathsf{(a \to b) \to Tree\,a \to Tree \,b}\\
\mathsf{map_{Tree}\, f\, (Leaf\,x)} & \mathsf{=} & \mathsf{Leaf\,(f\,x)}\\
\mathsf{map_{Tree}\, f\, (Node\,t_1\,x\,t_2)} & \mathsf{=} &
\mathsf{Node\,(map_{Tree}\, f \,t_1)\,x\,(map_{Tree}\,f\,t_2)}\\
\end{array}\]
Note, however, that the Church encoding of an ADT carries with it no
expectation whatsoever that such a type-and-data-uniform,
structure-preserving, data-changing $\mathsf{map}$ function can be
defined. It therefore need not satisfy any rearrange-transform
property either.

\subsection{ADTs as Primitive Data Types}

By contrast, the ability to define such a $\mathsf{map}$ function is
inherent in the view of ADTs as primitive data types. Such a view is
possible in any language that supports primitives for sum types,
product types, and recursion. In such a language, the primitive
representations of the ADTs $\mathsf{List\,a}$ and $\mathsf{Tree\,a}$
are
\begin{equation}\label{eq:list}
  \mathsf{List\,a} = \mathsf{\mu X.\, 1 + a \times X}
\end{equation}
and 
\begin{equation}\label{eq:tree}
  \mathsf{Tree\,a} = \mathsf{\mu X.\, a + X \times a \times X}
\end{equation}
respectively, where $\mathsf{\mu}$ is a primitive fixpoint operator.

Primitive representations capture in syntax the fact that ADTs can be
considered as fixpoints. For example $\mathsf{List\,a}$ is indeed a
fixpoint of $\mathsf{F_{List\,a}}$, where $\mathsf{F_{List\,a}\,X} =
\mathsf{1 + a \times X}$ as determined by~\eqref{eq:list}, i.e., is
indeed such that
\[\mathsf{List\,a} = \mathsf{1 + a \times List\,a}\] 
since every element of $\mathsf{List\,a}$ is either empty or is
obtained by $\mathsf{Cons}$ing an element of type $\mathsf{a}$ onto an
already-existing structure of type $\mathsf{List\,a}$. In fact, this
fixpoint equation is just a rewriting of the Haskell data type
declaration for $\mathsf{List\,a}$. We therefore have that
$\mathsf{List\, a} = \mathsf{\mu F_{List\,a}}$ is modelled by $\mu
F_{\mathit{List}\,a}$, where the functor $F_{\mathit{List}\,a}$ models
the type constructor $\mathsf{F_{List\,a}}$. Similarly, the ADT
$\mathsf{Tree\,a}$ can be seen to be a fixpoint of
$\mathsf{F_{Tree\,a}}$, where $\mathsf{F_{Tree\,a}\,X} = \mathsf{a + X
  \times a \times X}$ as determined by~\eqref{eq:tree}, so that
$\mathsf{Tree\, a} = \mathsf{ \mu F_{Tree\,a}}$ is modelled by $\mu
F_{\mathit{Tree}\,a}$, where $F_{\mathit{Tree}\,a} $ models
$\mathsf{F_{Tree\,a}}$.
 
These kinds of fixpoint equations are entirely sensible at the level
of types. But to ensure that the syntactic fixpoint representing an
ADT actually denotes a semantic object computed as a real-live
fixpoint, the semantic fixpoint calculation must converge.  If
{\color{blue} Since? Establish this earlier?} we interpret our types
as sets, then this means that the fixpoint being taken must be of a
{\em functor} on the category $\mathit{Set}$ of sets and functions
between them, rather than of a mere function between sets~\cite{tfca}.
That is, the function $F$ interpreting the type constructor
$\mathsf{F}$ constructing the body of a syntactic fixpoint must not
only have an action on sets, but must also have a {\em functorial
  action} on functions between sets. Reflecting this requirement back
into syntax gives that $\mathsf{F}$ must support a
suitable\footnote{The $\mathsf{map}$ function for $\mathsf{F}$ should
  satisfy syntactic reflections of the functoriality properties in
  $\mathit{Set}$ --- i.e., preservation of identity functions and
  composition of functions --- even though there is no mechanism in
  Haskell for enforcing this.} $\mathsf{map}$ function, i.e., must be
an instance of Haskell's $\mathsf{Functor}$ class.

Requiring $F$ to be a functor will ensure that the interpretation $\mu
F$ of the ADT $\mathsf{T\,a} = \mathsf{\mu F}$ exists. But to ensure
that $\mu F$ is itself a functor, so that the type constructor
$\mathsf{T}$ associated with the ADT $\mathsf{T\,a}$ supports a
$\mathsf{map}$ function as well, we can require that $F$ also be the
fixpoint $\mu H$ of a functor $H$. In this case, however, $H$ must be
a functor on the category $\mathit{Set}^\mathit{Set}$ of functors and
natural transformations on $\mathit{Set}$. That is, $H$ must be a {\em
  higher-order} functor on $\mathit{Set}$. Reflecting this requirement
back into syntax gives that
$\mathsf{T\,a} = \mathsf{(\mu H)\,a}$
for the ``type constructor constructor''
$\mathsf{H}$ that supports suitable\footnote{The $\mathsf{map}$
  function for $\mathsf{H}$ should satisfy syntactic reflections of
  the functoriality properties in $\mathit{Set}^\mathit{Set}$ ---
  i.e., preservation of identity natural transformations and
  composition of natural transformations --- and the $\mathsf{map}$
  function for $\mathsf{H\,F}$ should satisfy syntactic reflections of
  the functoriality properties in $\mathit{Set}$ as in the previous
  footnote. Again, there is no mechanism in Haskell for enforcing
  this.} $\mathsf{map}$ functions. 

%class HFunctor f where
%  ffmap :: Functor g => (a -> b) -> f g a -> f g b
%  hfmap :: (g :~> h) -> f g :~> f h
%
%  type (~>) f g = forall x. f x -> g x
       
      
A concrete example is given by the ADT $\mathsf{List\,a}$. This type
is modelled as the fixpoint $\mu F_{\mathit{List\,a}}$ of the
first-order functor whose action on sets is given by
$F_{\mathit{List}\,a}\,X = 1 + a \times X$ and whose action on
functions is given by $F_{\mathit{List}\,a}\,f = 1 + \id_a \times
f$. The type constructor $\mathsf{List}$ is modelled by the functor
that is the fixpoint $\mu H$ of the higher-order functor $H$ whose
action on a functor $F$ is given by the functor $H\,F$ whose actions
on sets and functions between them are given by $H\,F\,X = 1 + X
\times F\,X$ and $H\,F\,f = \id_1 + f \times F\,f$, respectively, and
whose action on a natural transformation $\eta$ is the natural
transformation whose component at $X$ is given by $(H\,\eta)_X = \id_1
+ \id_X \times \eta_X$. Reflecting the functorial action of $\mu H$
back into syntax gives exactly Haskell's built-in $\mathsf{map}$
function as the type-and-data-uniform, structure-preserving,
data-changing function associated with $\mathsf{List}$.

In a parametric model, short cut fusion can be used to show that the
Church encoding and the primitive representation of an ADT are
isomorphic as sets. Note, however, that whereas it is impossible even
to {\em state} the rearrange-transform property for Church encodings
of ADTs {\color{blue} unless we first define $\mathsf{map}$ functions
  for them}, this property is simply the reflection back into syntax
of the instance of naturality for the type-independent function that
rearranges structures of type $\mathsf{T\,a}$ into ones of type
$\mathsf{T'\,a}$ and the content-transforming functions
$\mathsf{map_T\,f}$ and $\mathsf{map_{T'}\,f}$ for a function
$\mathsf{f :: a \to b}$, where $\mathsf{T}$ and $\mathsf{T'}$ are the
type constructors associated with these ADTs, respectively.

\section{Representations of GADTs}\label{sec:gadts}

GADTs relax the restriction on the type instances appearing in a data
type definition. The special form of GADTs known as {\em nested types}
allow the data constructors of a GADT to take as arguments data whose
types involve type instances of the GADT other than the one being
defined. For example, the definition
\[\mathsf{PTree \, a = PLeaf \,a \,|\, PNode \,(PTree\,(a \times
  a))}\] of the nested type $\mathsf{PTree\,a}$ of perfect trees
introduces the data constructor(s $\mathsf{PLeaf :: a \to PTree\,a}$
and) $\mathsf{PNode :: PTree \,(a\times a) \to PTree\,a}$. It enforces
not only the invariant that all of the data in a structure of type
$\mathsf{PTree\,a}$ is of the same type $\mathsf{a}$, but also the
invariant that all perfect trees have lengths that are powers of
2. More general GADTs allow their constructors both to take as
arguments {\em and return as results} data whose types involve type
instances of the GADT other than the one being defined. An example is
the GADT $\mathsf{Seq}$ given in~\eqref{eq:seq}. Note that since the
return type of the data constructor $\mathsf{Pair}$ is not of the form
$\mathsf{Seq\,a}$ for any variable $\mathsf{a}$, $\mathsf{Seq}$ is a
GADT that is not a nested type.

By contrast with the ADT $\mathsf{List\, a}$, where the type parameter
$\mathsf{a}$ is integral to the type being defined, the type parameter
$\mathsf{a}$ appears in both $\mathsf{PTree\,a}$ and $\mathsf{Seq\,a}$
as a ``dummy'' parameter used only to give the kind \verb|* -> *| of
the type constructors $\mathsf{PTree}$ and $\mathsf{Seq}$. This is
explicitly captured in the alternative ``kind signature'' Haskell
syntax
\[\begin{array}{l}
\mathsf{data\, Seq :: * \to *\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Const ::\, a \to Seq\,a}\\
\mathsf{\;\;\;\;\;\;\;\;Pair\,\,\,\,\, ::\, Seq \,a \to Seq\,b \to
  Seq\,(a \times b)}\\ 
\end{array}\]
A GADT --- even a nested type --- thus does not define a {\em family
  of inductive types}, one for each type argument, like an ADT does,
but instead defines an entire family of types that must be constructed
simultaneously. That is, a GADT defines an {\em inductive family of
  types}.

\subsection{Church Encodings of GADTs}\label{sec:CEs}

The syntax of GADTs is consistent with programmers' use of them in
situations where different behaviors at different type instances is
desired. This is achieved by allowing the progammer to give the type
signatures of the different data constructors independently, and then
using pattern matching to force the desired type refinement.  Typical
applications of GADTs include generic programming, modeling
programming languages via higher-order abstract syntax, maintaining
invariants in data structures, and expressing constraints in embedded
domain-specific languages. They have also been used, e.g., to
implement tagless interpreters~\cite{pl04,pr06,pvww06}, to improve
memory performance~\cite{min15}, and to design APIs~\cite{pen20}.

Allowing non-variable type arguments in the return types of a GADT's
data constructors establishes a strong connection between a GADT's
shape and the data it contains. With ADTs, we first choose the shape
of the container and then fill that container with data of whatever
type we like. Critically, the choice of shape is independent of the
data to be stored. With GADTs, however, the shape of the container may
actually {\em depend} on (the type of) the data to be contained. For
example, $\mathsf{Const}$ can create data of any shape
$\mathsf{Seq\,a}$, but $\mathsf{Pair}$ can produce data of shape
$\mathsf{Seq\,a}$ only if $\mathsf{a}$ is a pair type. As a result,
modifying the data in a GADT may actually change the shape of --- or
may even destroy! --- the GADT.

To determine the possible shapes of a GADT's container we have to
pattern-match on the type of the data to be contained. For this, it is
essential that a GADT calculus support an equality type
$\mathsf{Equal}$ that is a singleton set when its two type arguments
are the same and is the empty set otherwise. That is, the type
$\mathsf{Equal}$ must be the syntactic reflection of semantic equality
function $\mathit{Equal}$. The type $\mathsf{Equal}$ can either be
defined via GADT syntax, as in
\[\begin{array}{l}
\mathsf{data\, Equal\,a\,b\,where}\\
\mathsf{\;\;\;\;\;\;\;\;Refl ::\, Equal\,c\,c}\\
\end{array}\]
\noindent
or, equivalently, represented by its own Church encoding
\[\mathsf{Equal\,a\,b} = \mathsf{\forall f.\, (\forall c.\,
  f\,c\,c) \to f\,a\,b}\]
The GADT $\mathsf{Seq}$ can then be represented as its Church encoding
\[\mathsf{Seq\,a} = \mathsf{\forall f.\, (\forall a.\,a \to f\, a)
  \to (\forall a\,b\,c.\,Equal\,a\,(b\times c) \to f\,b \to f\,c \to
  f\,a) \to f\,a}\]
in a higher-kinded calculus such as $F_\omega$~\cite{atk12}.

Importantly, the function $\mathit{Equal}\,a$ cannot be made into a
functor. Equivalently, $\mathsf{Equal\,a}$ (in either representation)
cannot be made an instance of Haskell's $\mathsf{Functor}$
class. Indeed, if $\mathsf{Equal\,a}$ supported a function
\[\mathsf{map_{Equal\,a} :: (b \to c) \to Equal\,a\,b \to
  Equal\,a\,c}\]
then defining
\[\begin{array}{l}
\mathsf{eqElim :: Equal\, a\, b \to b \to a}\\
\mathsf{eqElim\, Refl\, x = x} 
\end{array}\]
would allow us to construct an element 
\[\begin{array}{l}
\mathsf{emptyFromMapEquala :: (\forall b\, c.\, (b \to c) \to Equal\, a\,
  b \to Equal\, a \,c) \to Void}\\ 
\mathsf{emptyFromMapEquala \,map_{Equal\,a} = eqElim\, (map_{Equal\,a}\,
  absurd\, Refl)\, ()}  
\end{array}\]
of type $\mathsf{Void}$. {\color{blue} Use same type conventions as in
  Intro.} But this should be impossible. It is immediate that a GADT
that is not actually a nested type cannot support a $\mathsf{map}$
function (or a rearrange-transform property) either. In the case of
$\mathsf{Seq}$, this is already intuitively evident from its Haskell
definition as discussed in Section~\ref{sec:intro}.

\subsection{GADTs as Primitive Data Types}\label{sec:prim-gadts}

The Church encoding of a GADT corresponds to the data type comprising
just those elements specified by the GADT's syntax. By contrast, the
primitive representation of a GADT corresponds to the data type
comprising all data elements in the functorial completion of the
GADT's syntax. In this alternate reading, GADTs can, like ADTs, be
modelled as fixpoints of higher-order functors. Syntactically, the use
of higher-order funct{\em ions} is essential; since the type arguments
to the GADT being defined are not necessarily uniform across all of
its instances in the types of its data constructors, GADTs cannot be
seen as fixpoints of first-order functors the way ADTs
can. Semantically, the use of higher-order funct{\em ors} is
essential, as in the case of ADTs, to guarantee the existence of the
fixpoints being computed~\cite{tfca}.

Consider, again, the GADT $\mathsf{Seq}$. Because its type argument
varies in the instances of $\mathsf{Seq}$ appearing in the types of
its data constructor $\mathsf{Pair}$, $\mathsf{Seq}$ cannot be
modelled as the fixpoint of any first-order functor. As shown
in~\cite{jp19}, it can, however, be modelled as a solution to the
higher-order fixpoint equation
\[H\,f\,a = a \,+\,(Lan_{\lambda c d. c \times d}\, \lambda
c d. f c \times f d)\,a\]
{\color{red} Check this equation against next displayed one below.}
where $Lan_K \,F$ is the left Kan extension of
the functor $F$ along the functor $K$. In general, the left Kan
extension $Lan_K \,F : {\cal E} \to {\cal D}$ of $F : {\cal C} \to
{\cal D}$ along $K : {\cal C} \to {\cal E}$ is the best functorial
approximation to $F$ that factors through $K$. Here, ``best functorial
approximation'' means that $Lan_K \,F$ is the smallest functor that
both extends the image of $K$ to $\cal D$ and coincides with $F$ on
$\cal C$, in the sense that, for any other such functor $H$, there is
a morphism of functors (i.e., a natural transformation) from $Lan_K
\,F$ to $H$. This is captured formally by the following
definition~\cite{mac71}:
\begin{definition}\label{def:lke}
If $F : {\cal C} \to {\cal D}$ and $K : {\cal C} \to {\cal E}$ are
functors, then the {\em left Kan extension of $F$ along $K$} is a
functor $\mathit{Lan}_K\,F : {\cal E} \to {\cal D}$ together with a
natural transformation $\eta : F \to (\mathit{Lan}_K\,F) \circ K$ such
that, for every functor $H : {\cal E} \to {\cal D}$ and natural
transformation $\gamma : F \to H \circ K$, there exists a unique
natural transformation $\delta : \mathit{Lan}_K\,F \to H$ such that
$(\delta K) \circ \eta = \gamma$. This is depicted in the diagram
\[\begin{tikzcd}[row sep = huge]
{\cal C}
\ar[rr, "{F}"{name=Fa, above}, ""{name=F, below}]
\ar[rd, "{K}"']
&& {\cal D} \\
& {\cal E}
\ar[Rightarrow, bend right = 25, from=F, "{\eta}"']
\ar[ur, bend left, "{\mathit{Lan}_{K}\,F}"{name=Lan, description}]
\ar[ur, bend right, "{H}"'{name=L, right}, ""'{name=Lr, right}]
\ar[Rightarrow, bend left = 45, from=Fa, to=Lr, "{\gamma}" near start]
\ar[Rightarrow, dashed, from=Lan, to=L, "{\delta}"']
\end{tikzcd}\]
\end{definition}

To represent GADTs as primitive data types in a setting in which types
are interpreted as sets, a calculus must support a primitive construct
$\mathsf{Lan}$ such that the type constructor $\mathsf{Lan_k\,f}$ is
the syntactic reflection of the left Kan extension $\Lan_K \,F$ of the
functor $F$ interpreting $\mathsf{f}$ along the functor $K$
interpreting $\mathsf{k}$. In this setting, the categories
$\mathcal{C}$, $\mathcal{D}$, and $\mathcal{E}$ must all be
$\mathit{Set}$. Using $\mathsf{Lan}$ we can then rewrite the type of a
constructor $\mathsf{c :: f a \to g(k\,a)}$ as $\mathsf{c ::
  (Lan_k\,f)\,a \to g\,a}$ since morphisms (i.e., natural
transformations) from $F$ to $G \circ K$ are in one-to-one
corresondence with those from $\mathit{Lan}_K\,F$ to $G$ (see,
e.g.,~\cite{rie16}). That is, writing $F \Rightarrow G$ for the set of
natural transformations from a functor $F$ to a functor $G$, we have
\begin{equation}\label{eq:nat-transfs}
F \Rightarrow G \circ K\; \simeq \; Lan_K\,F \Rightarrow G
\end{equation}
The calculus must also support a primitive type
constructor $\mathsf{\mu}$ that is the syntactic reflection of the
(now higher-order) fixpoint operator on
$\mathit{Set}^\mathit{Set}$. Using $\mu$ and $\Lan$ we can then
represent a GADT as a higher-order higher-order fixpoint. For example,
we can represent the GADT $\mathsf{Seq}$ as
\[\mathsf{Seq\,a} = \mathsf{(\mu \phi.\lambda b.\, b + (Lan_{\lambda c
    d. c \times d} \lambda c d. \phi c \times \phi d)\,b)\,a}\] The
fact that $Lan_K\,G$ is the best functorial approximation to $G$
factoring through $K$ means that the type constructor
$\mathsf{Lan_k\,g}$ computes the smallest collection of data that is
generated by the corresponding GADT data constructor's syntax and also
supports a $\mathsf{map}$ function. The primitive representation of
any GADT thus comprises the smallest data type that both includes the
data specified by that GADT's syntax and also supports a
$\mathsf{map}$ function (and thus a rearrange-transform property). In
the primitive view, then, GADTs are generally underspecified by their
syntax.

In this section we have seen that GADTs can be represented either as
Church encodings or as primitive data types. This exactly mirrors the
situation for ADTs described in Section~\ref{sec:adts}. But whereas
the two representations are always isomorphic for ADTs, they are not,
in general, the same for GADTs. This will be proved in the next
section.

\section{Non-Equivalence of Church Encodings and Primitive
  Representations of GADTs}\label{sec:non-equiv}

{\color{blue} Is G or G\,a the GADT?}

To see that the Church encoding of a GADT and its primitive
representation need not be the same, consider again the GADT
$\mathsf{G}$ defined in~\eqref{eq:G}. Despite its simplicity, this
GADT serves as an informative case study highlighting the differences
between a GADT's Church encoding its primitive representation --- even
if we consider only the data elements it contains, and ignore whether
or not it supports a $\mathsf{map}$ function.

\begin{example}\label{ex:g1}
Syntactically, the GADT $\mathsf{G}$ defined in~\eqref{eq:G} comprises
a single data element, namely $\mathsf{c :: G \, 1}$. This is captured
by $\mathsf{G}$'s Church encoding
\[\mathsf{G\,a} = \mathsf{Equal\,1\,a}\]
from~\cite{atk12}. As its Church encoding makes clear, $\mathsf{G}$'s
effect is simply to test its argument for equality against the unit
type $\mathsf{1}$. {\color{blue} Use same notation for unit type as in
  intro.} The interpretation of the Church encoding of $\mathsf{G}$
is thus, in accordance with Section~\ref{sec:CEs}, the function whose
value is a singleton set when the interpretation of $\mathsf{a}$ is
$1$ and the empty set otherwise. This perfectly accords with
$\mathsf{G}$'s syntax, which indeed delivers just one data element
when $\mathsf{a}$ is $\mathsf{1}$ and no elements otherwise.

To compute the interpretation of $\mathsf{G}$'s primitive
representation we first note that the type of $\mathsf{G}$'s solitary
constructor $\mathsf{c :: G\,1}$ can be equivalently expressed as
$\mathsf{c :: 1 \to G\,1}$ or, using~\eqref{eq:nat-transfs}, as
$\mathsf{c :: (Lan_{\lambda *. 1}\,\lambda *. 1)\,a \to G\, a}$, where
$\mathsf{\lambda *. 1}$ is the syntactic reflection of the constantly
$1$-valued functor from the category with a single object $*$ to
$\mathit{Set}$. We can therefore represent $\mathsf{G}$ as
\[\mathsf{G\,a} = \mathsf{(\mu \phi. \lambda b.
 (Lan_{\lambda *. 1} \,\lambda *.  1)\,b)\,a}\] The interpretation of
$\mathsf{G}$ is therefore the application to $\mathsf{a}$ of the
fixpoint of the interpretation of the body $\mathsf{\lambda
  b. (Lan_{\lambda *. 1} \,\lambda *. 1)\,b}$ of the syntactic
fixpoint $\mathsf{\mu \phi. \lambda b.  (Lan_{\lambda *. 1} \,\lambda
  *.  1)\,b}$. But since the recursion variable $\mathsf{\phi}$ does
not appear in this body, the interpretation of the fixpoint is just
the interpretation of the body itself.  The interpretation of
$\mathsf{G\,a}$ is therefore $(\mathit{Lan}_{\lambda *. 1} \lambda
*. 1)\, A$, where $A$ interprets $\mathsf{a}$.
%and $1$ is the {\color{blue} constantly $1$-valued
%  functor $\ast \to \set$ from the category with a single object
%  $\ast$ to $\set$.}
It turns out, however, that, for any set $A$, $(\mathit{Lan}_{\lambda
  *. 1} \lambda *. 1)\,A$ is, in fact, exactly $A$. Indeed,
Proposition~7.1 of~\cite{blw03} gives that $(\mathit{Lan}_{\lambda
  *. 1} \lambda *. 1)\,A$ can be computed as the set of all functions
$a : 1 \to A$ modulo the smallest equivalence relation $\sim$ such
that, for any $f : 1 \to 1$, we have $a \sim a \circ f$.  But this set
is isomorphic to $A$, because the only function $f : 1 \to 1$ is the
identity function.


Putting it all together, we see that the Church encoding of
$\mathsf{G}$ and its primitive representation are not semantically
equivalent: the interpretation of the former has exactly one data
element at instance $\mathsf{G\,1}$ and no elements at any other
instances, whereas the interpretation of the latter has data elements
at every instance other than $\mathsf{G\,0}$.
%Indeed,
These additional data elements can be obtained by reflecting back into
syntax the elements $\mathit{map}_G\,f_a\,c : G\,A$ resulting from
applying the functorial action $\mathit{map}_G$ of $\mathsf{G}$'s
interpretation $G$ to the functions $f_a : 1 \to A$ determined by the
elements $a$ of $A \not = \emptyset$ and the interpretation $c$ of
$\mathsf{c}$.
\end{example}

Forced to choose, a programmer would likely find the idea that a GADT
contains data not specified by its syntax more than a little
disturbing. What, they might ask, should a data type contain other
than data that are constructed using its data constuctors? Why should
a GADT contain ``hidden'' elements that are not specified by the
GADT's syntax and are only accessible via applications of
$\mathsf{map}$? A semanticist, on the other hand, would likely find
the primitive representation of GADTs entirely reasonable. Indeed,
they would likely find the nonfunctorial nature of a GADT's Church
encoding unnerving at best. After all, they would likely argue, the
data in a GADT shouldn't disappear just because you map a function
over it! The fact that this happens when GADTs are represented by
their Church encodings actually highlights how GADTs {\em do not}
generalize the essential, container-ish nature of ADTs at all. A
semanticist might therefore conclude that GADTs are seriously
misnamed. They might even go on to wonder: in what sense do GADTs
really deserve to be considered {\em data types} at all?

The reader familiar with short cut fusion will quickly see that the
non-uniform nature of GADTs that are not nested types entails that
short cut fusion cannot be validated for their Church encodings. In
fact, it is not even possible to define a $\mathsf{build}$ function,
which is a crucial ingredient in short cut fusion, for the Church
encoding of a GADT that is not a nested type. But the fact that not
all of the elements in the functorial completion of a GADT that is not
a nested type are directly representable as applications of data
constructors means that it is also impossible to define a
$\mathsf{build}$ function for the primitive representation of such a
GADT.  This is not surprising, however: if short cut fusion were to
hold for a GADT then its Church encoding and primitive representation
would necessarily be semantically equivalent.

In addition to not being semantically equivalent, the two
representations of GADTs have very different implications for
parametricity. We explore the differences in parametricity results for
GADTs with respect to the two representations in the next section.

\section{Parametricity for GADTs}\label{sec:par}

{\em Relational parametricity} encodes a powerful notion of
type-uniformity, or representation independence, for data types in
functional languages. It formalizes the intuition that a polymorphic
program must act uniformly on all of its possible type instantiations
by requiring that every such program preserves all relations between
pairs of types at which it is instantiated. Parametricity was
originally put forth by Reynolds~\cite{rey83} for System F. It was
later popularized as Wadler's ``theorems for free''~\cite{wad89}, so
called because it can deduce properties of programs in such languages
solely from their types, i.e., with no knowledge whatsoever of the
text of the programs involved.  Most of Wadler's free theorems are
consequences of naturality for polymorphic list-processing
functions. However, parametricity can also derive results that go
beyond just naturality, such as proving equivalence of Church
encodings and primitive representations of ADTs and {\color{blue}
  hereditarily polynomial} nested types by validating short cut fusion
for them.

To discuss relational parametricity will need to interpret data types
not just in $\mathit{Set}$, but in a suitable category of relations as
well. The following definition is standard:
\begin{definition}
  The category $\mathit{Rel}$ has:
  \begin{itemize}
\item objects: A relation is a triple $(A,B,R)$, where $R$ is a
  relation between sets $A$ and $B$.
\item morphisms: A morphism from $(A,B,R)$ to $(A',B',R')$ is a pair
  $(f : A \to A',g : B \to B')$ of functions in $\mathit{Set}$ such
  that $(f a,g\,b) \in R'$ if $(a,b) \in R$.
\item identities: The identity morphism on $(A,B,R)$ is the pair
  $(\mathit{id}_A : A \to A, \mathit{id}_B : B \to B)$.
\item composition: Composition is the componentwise composition in
  $\mathit{Set}$. 
\end{itemize}
\end{definition}
\noindent
We write $R : \mathit{Rel}\,(A,B)$ for $(A,B,R) \in \mathit{Rel}$.  If
$R : \mathit{Rel}\,(A,B)$ then we write $\pi_1 R$ and $\pi_2 R$ for
the {\em domain} $A$ of $R$ and the {\em codomain} $B$ of $R$,
respectively. Below, we assume $\pi_1$ and $\pi_2$ are surjective.  We
write $\mathit{Eq}_A = (A,A,\{(x,x)~|~ x \in A\})$ for the {\em
  equality relation} on the set $A$.

The key idea underlying parametricity is to give each type
$\mathsf{G[a]}$ with one free variable $\mathsf{a}$ a {\em set
  interpretation} $G_0$ taking sets to sets and a \emph{relational
  interpretation} $G_1$ taking relations $R : \mathit{Rel}\,(A,B)$ to
relations $G_1 \,R : \mathit{Rel}\,(G_0 \,A, G_0 \,B)$, and to
interpret each term $\mathsf{t\,(a,x) :: G[a]}$ with one free term
variable $\mathsf{x :: F[a]}$ as a function $t$ associating to each
set $A$ a morphism $t \,A : F_0\,A \to G_0\,A$ in $\mathit{Set}$.
These interpretations are given inductively on the structures of
$\mathsf{G}$ and $\mathsf{t}$ in such a way that they imply two
fundamental theorems. The first is an \emph{Identity Extension Lemma},
which states that $G_1\,\mathit{Eq}_A = \mathit{Eq}_{G_0 A}$, and is
the essential property that makes a model relationally parametric
rather than just induced by a logical relation.  The second is an
\emph{Abstraction Theorem}, which states that, for any $R
:\mathit{Rel}\,(A, B)$, $(t\, A, t\,B)$ is a morphism in
$\mathit{Rel}$ from $(F_0\,A,F_0\,B,F_1\,R)$ to
$(G_0\,A,G_0\,B,G_1\,R)$. The Identity Extension Lemma is similar to
the Abstraction Theorem except that it holds for {\em all} elements of
a type's interpretation, not just those that interpret terms.  Similar
theorems are required for types and terms with any number of free
variables.

The existence of parametric models that interpret GADTs as the
interpretations of their Church encodings follows from, e.g., the
existence of the parametric model of $F_\omega$ constructed
in~\cite{atk12}.  In that model, {\color{blue} ``parallel
  interpretations'' of $Rel$ over $Set$...}.  The parametricity
property for a GADT is therefore...  {\color{blue} SAY MORE!} In
particular, the parametricity property for the GADT $\mathsf{G}$
from~\eqref{eq:G} is exactly the syntactic counterpart of the
inhabitation result for the interpretation of $\mathsf{G}$'s Church
encoding, as the following example shows.

\begin{example}
Let $\mathsf{t}$ be a term of type $\mathsf{G}$ for the GADT
$\mathsf{G}$ defined in~\eqref{eq:G}, let $G = (G_0,G_1)$ be the
interpretation of the Church encoding of $\mathsf{G}$, let $t$ be the
interpretation of $\mathsf{t}$, and let $R :
\mathit{Rel}\,(A,B)$. Then $t\, A \in G_0\,A$ and $t\,B \in G_0\,B$
and, by the Abstraction Theorem, $t\,A$ and $t\,B$ are related in
$G_1\,R$. However, {\color{blue} using the semantic interpretations
  in~\cite{atk12} --- EXPLAIN!}, we have that the relational
interpretation $G_1\,R$ of $\mathsf{G}$ is the empty relation whenever
$R$ differs from the relational interpretation $\mathit{Eq}\,1$ of
$\mathsf{1}$.  {\color{blue} $Eq$ vs. $Equal$?}  We thus deduce that
there can be no term of type $\mathsf{G\,a}$ unless $\mathsf{a}$ is
semantically equivalent to $\mathsf{1}$.
\end{example}

For primitive representations of GADTs the story is completely
different. First off, we have that {\color{blue} the interp of Lan
  must be full Lan}. Indeed,... {\color{blue} MORE!!}
\begin{proposition}\label{prop:full-lans}
Full Lan prop goes here. Explain cutting down.
\end{proposition}
\noindent
In particular, both the set interpretation and the relational
interpetation of a GADT must involve the entireties of any Lans in
their fixpoint representations. We therefore have:

\begin{example}
In any parametric model we must give both a set interpretation and a
relational interpretion for every type as described at the start of
this section. That is, for every GADT $\mathsf{G}$ we must give an
interpretation $G = (G_0,G_1)$ such that, for every relation $R :
\mathit{Rel}\,(A, B)$, we have $G_1\,R : \mathit{Rel}\,(G_0\,A,
G_0\,B)$. But, as we now show, this is not generally possible for in
models that interpret GADTs as the interpretations of their primitive
representations.

Consider again the GADT $\mathsf{G}$ given by~\eqref{eq:G}.  Applying
Proposition~\ref{prop:full-lans} first in $\mathit{Set}$ and then in
$\mathit{Rel}$, we have that the set interpretation of $\mathsf{G}$ is
$\mathit{Lan}_{\lambda *.1}\,\lambda *.1$, i.e., is exactly the
identity functor on $\mathit{Set}$ {\color{blue} Tie back to previous
  calculation}. By the exact same reasoning, this time in
$\mathit{Rel}$ rather than in $\mathit{Set}$, the relational
interpretation of $\mathsf{G}$ is $\mathit{Lan}_{\lambda
  *.\mathit{Eq}_1} \,\lambda *\!.\,\mathit{Eq}_1$, where $\lambda
*\!.\,\mathit{Eq}_1$ is the constantly $\mathit{Eq}_1$-valued functor
from the category with a single object $*$ to $\mathit{Rel}$.  Indeed,
the interpretation is still a left Kan extension, but now it is the
left Kan extension determined by the functor interpreting the type
$\mathsf{\lambda *. 1}$ in $\mathit{Rel}$. To prove that the Identity
Extension Lemma holds we need to show that, for every relation $R :
\mathit{Rel}\,(A, B)$, we have that $(\mathit{\Lan}_{\lambda
  *\!.\,\mathit{Eq}_1} \,\lambda *\!.\,\mathit{Eq}_1)\, R$ is a
relation between the sets $(\mathit{Lan}_{\lambda *. 1}\,\lambda
*\!. 1)\, A$ and $(\mathit{Lan}_{\lambda *. 1}\,\lambda *\!. 1)\,B$,
i.e., between the sets $A$ and $B$.  Instead, we will give a
counterexample showing that this is not the case.

Consider the relation $R = (1, 2, 1 \times 2)$. We expect
$(\mathit{\Lan}_{\lambda *\!.\,\mathit{Eq}_1} \lambda
*\!.\,\mathit{Eq}_1)\, R$ to be a relation with domain {\color{blue}
  $1$}. Since left Kan extensions preserve projections~\cite{rie16},
we can compute the domain as
\[\pi_1\,\big( (\mathit{\Lan}_{\lambda *\!.\,\mathit{Eq}_1} \lambda
*\!.\,\mathit{Eq}_1) \, R \big)\;=\; (\mathsf{\Lan}_{\lambda
  *\!.\,\mathit{Eq}_1} \lambda *\!. \,1)\, 1\]



(notice that the left
Kan extension of $1 : \ast \to \set$ along $\Eq_1 : \ast \to \rel$ is
a functor $\rel \to \set$).



Consider the relation $R = (1, \emptyset, \emptyset)$.  We would thus
expect $(\mathsf{\Lan}_{\Eq_1} \Eq_1) R$ to be a relation with domain
$1$.  Because the left Kan extension preserves
projections~\cite{rie16} we can compute the domain as
$(\mathsf{\Lan}_{\Eq_1} 1) R$ (notice that the left Kan extension of
$1 : \ast \to \set$ along $\Eq_1 : \ast \to \rel$ is a functor $\rel
\to \set$).

Following~\cite{blw03} we know that $(\mathsf{\Lan}_{\Eq_1} 1) R$ is
the set of all morphisms of relations $f : \Eq_1 \to R$ modulo an
equivalence relation; but there can be no morphism of relations $\Eq_1
\to R$ because its second component would have to be a function $1 \to
\emptyset$, and there can be no such function.  Thus,
$(\mathsf{\Lan}_{\Eq_1} 1) R = \emptyset$, which is not the domain we
would have expected.
\end{example}

The above example shows that the set interpretation and the relational
interpretation for the primitive representation of a data type are
inconsistent with each other, and thus it is not even possible to
consider the question of whether the semantics is parametric.

One could regard the above example as artificial, as it employs an
empty relation on a non-empty domain.  Though, it is possible to apply
the same argument, with a slightly more complex calculation, even to a
total relation such as $(1, 2, 1 \times 2)$.



\vspace*{0.2in}

Although there can exist no parametric models interpreting GADTs as
their primitive representations, we still get naturality properties
for prim reps. On the other hand, although a GADT represented as a
Church encoding does not necessarily have a map or a functorial
semantics, so that we cannot possibly derive naturality results for
them, parametric models interpreting GADTs as their Church encodings
do exist.  This shows that, even though naturality is generally
regarded as a consequence of parametricity, this is only true when we
have a functorial semantics and types supporting a map.

%%% Primitive representation of GADT is non parametric, but functorial
%On the contrary, as we have shown in Section~\ref{sec:gadts}, a
%GADT represented as a primitive data type does not necessarily admit a
%parametric semantics, but, as a fixpoint of a higher-order functor, it
%does admit a functorial semantics and, consequently, a functorial map.
%In particular, every type that has a functorial map also benefits from
%naturality properties.  In other words, there is a suitable
%rearrange-transform property as explained in Section~\ref{sec:gadts}.

We can read the results of this section as showing that parametricity
results for calculi representing GADTs as their Church encodings
cannot be extended to calculi that represent GADTs as primitive data
types. And functoriality results for calucli representing GADTs as
primitive cannot be extended to calculi that represent GADTs as their
Church encodings.  So the user is forced to make a choice between
naturality consequences of parametricity and other consequences of
parametricity. If GADTs really did generalize ADTs, and really were
data types in a normal sense, then these would coincide and the user
would not have to choose.

\vspace*{0.2in}

NOTES:

{\color{violet} TRUE????}
FOR ADTs and Nesteds, it does not depend. We get the same par property
whether they are seen as primitives or we use their CE.


\begin{comment}
{\color{violet} This is already in the paper, split in multiple places.}
An analysis of the Eq A B type in Bob's systems shows that the set
interpretation is empty whenever the A and B have different set
interpretations.  Likewise, its relational interpretation is the empty
relation whenever the A and B have different relational
interpretations (even when the underlying set interpretations are the
same).  The consequences of parametricity are thus immediate: there
can be no term of type Eq A B if A and B are different types.
Moreover, this behavior is fundamentally non-functorial, so that there
is no hope of defining a map for Eq.  In particular, that means we
cannot expect to retrieve non-trivial naturality properties for the Eq
type, despite these are usually considered to be a special case of
parametricity properties.  Indeed, the common understanding that
parametricity generalizes naturality only makes sense for functorial
types.  We can specialize these considerations to the type Eq 1 B,
representing G, our example GADT defined by a unique constructor c ::
G 1.
\end{comment}

\pagebreak


\subsection{Comparison with Stephanie and Dmitrios}


\subsection{Comparison with Bob's Parametric Model}

GADTs don't really fit into his scheme because the two reps of GADTs
aren't the same. Bob's stuff only works for functorial data types of
any kind -- so not GADTs. So last section is misleading.





Moreover, the consequences of parametricity that one has in Bob's
system do not hold in our system, as we can construct terms of type
$(Lan_1 1)$ B for instances of B other than 1.  Thus, either our
system does not admit any parametric model, or, if it does, the
consequences of parametricity are different.  That the consequences of
parametricity depended on the model or the representation of GADTs is
to be expected, however. (IT IS. CONSIDER INTERPRETING BASE TYPES AS
ORDERED SETS. THIS GIVES DIFFERENT PARAMETRICITY PROPERTIES THAN
INTERPRETING THEM AS DIAGONAL RELATIONS.)

It is possible to give a parametric model that models GADTs
represented as Church encodings~\cite{atk12}.  But given the
non-uniformity captured by GADTs by purposeful design, that should be
both completely unexpected and alarming! However, upon reflection it's
not really all that surprising once we realize what the parametricity
properties of GADTs represented as Church encodings look like. Bob
requires map functions for fixpoint but then doesn't use them.

Tellingly, Bob gives no parametricity properties for GADTs. If he had,
it would have illustrated the phenomenon we are describing, raised the
question: What good is a par property for a GADT or another type using
the Eq type?

That parametricity properties for GADTs in Bob's system are as we
described before is interesting because, for ADTs and nested types,
which GADTs claim to generalize, we expect naturality to be a special
case of parametricity. However, we don't actually get non-trivial
naturality consequences of parametricity for GADTs in Bob's
system. Why? Because this would require GADTs to be interpreted as
functors, which, in Bob's system, requires the programmer to supply a
map function on the intepretation of every GADT defined. Moreover,
each such map function would have to behave functorially. Bob's system
does indeed deliver non-trivial naturality results for every GADT for
which the user can define a map function that behaves
functorially. The problem is that there may not be many such GADTs (in
fact it will not be possible for proper GADTs, i.e., GADTs that are
not actually nested types).

Perhaps expecting naturality as a special case of parametricity is
wrongheaded, though, since, with its arbitrary forall-types and arrow
types, System F is inherently non-functorial. Using Church encodings,
Bob's system handles arbitrary GADT syntax. However, GADTs are not
guaranteed to behave functorially in his system, and the user is
ultimately tasked with supplying the relevant map functions (and
proving their properties) for any GADTs they want to work with. That
the user must supply the map function for a GADT of interest makes
sense: Church encodings cannot say anything about functorial nature of
data types since they describe only the data (and not the action on
morphisms since they are not required to support map functions).  Our
approach is different. By contrast with Bob's system, we restrict to
GADTs generated by a specific grammar, and this grammar is designed
specifically to guarantee functoriality of all data types definable in
it. We also treat GADTs as primitive data types --- i.e., as fixpoints
of (higher-order) functors --- rather than via their Church encodings
since this more closely aligns with how ADTs are treated in
implemented programming languages.

Wrt Bob's system we can ask: what good is parametricity for GADTs in a
system that derives only trivial naturality consequences of
parametricity for them? It may be possible to get non-naturality
consequences of parametricity (such as short cut fusion or
VYTINIOTIS'?) for GADTs in Bob's system (IS IT?), but since many of
the most useful consequences of parametricity for ADTs and nested
types are actually natuality results (IS THIS TRUE? MAYBE NOT FOR
GADTs), we'd be missing out on a very large class of expected and
useful free theorems. Indeed, many of Wadler's free theorems are
precisely naturality results for functions over data types (mainly
lists, there). If GADTs really do generalize ADTs (and nested types)
then we would expect to be able to derive analogues for GADTs of the
parametricity results --- including naturality results --- that we can
derive for ADTs. Yet, by design we cannot. So are GADTs actually
misnamed? In what sense are they data types, and in what sense do they
generalize ADTs? Perhaps what are now known as nested types should
really be called GADTs since *they* are actually the (level-2)
higher-kinded generalizations of ADTs.

{\color{violet} We say "naturality consequences of parametricity"
when in fact we have naturality without having any parametricity at all.
Change the wording to indicate that naturality follows from
functoriality of the interp.}
In our system we can show that we can recover the expected naturality
consequences of parametricity for (at least a large class of) GADTs
(that can be characterized by a grammar for which every type is
interpreted as a functor, including those characterized as least
fixpoints, i.e., as carriers of initial algebras of functors, i.e., as
primitive data types). The way our system achieves this is by
interpreting GADTs as their functorial completions. So in our system
the interpretations of GADTs are guaranteed to have fmap functions ---
i.e., to be functorial --- and to satisfy the expected naturality
properties. And our free theorems really are free for GADTs that fit
our syntax. But now the bump is elsewhere under the rug: First,
semantically we don't really have the same GADT anymore (functoriality
adds extra data to the data type), and second, our counterexample
shows that we don't get non-naturality consequences of parmetricity
even for the data types defined by our grammar.  So this isn't really
what we wanted either.



\pagebreak

\begin{verbatim}
  
Daniel:

I have tried reconstructing my example using our simpler GADT with a single
constructor c :: G 1. I don't think it is possible to modify my example for a
GADT with only a single constructor. In particular, I don't see a way to
exploit the map function unless we have constructors for G X and G Y where X
!= Y.
If we assume a map function exists, then given f :: 1 -> A we can produce
(map f c) :: G A. But I don't know what to do from there.

I was able to simplify the types in the example slightly though. The example
I gave before can be adapted to use either

data G3 b where
  G3unit :: G3 ()
  G3id  :: b -> G3 (Either b ())

or

data G5 b where
  G5unit  :: G5 ()
  G5void  :: Void -> G5 Bool

as the problematic GADT.

Enrico:

Just to make sure I understand it correctly: when we define the function

unGbool :: G c Bool -> c
unGbool (Gbool x) = x

we are doing so in Haskell, right?
In our system, it would not be possible to define unGbool (because we could
not define it only on the constructor Gbool of G). For this reason, this
example provides a contradiction in Haskell (+functoriality), but not in our
system. Is that correct?

Daniel:

The example is Haskell and relies on Haskell's rules for
pattern matching.








Enrico:

By the way, as a general remark not directly related to the introduction you
wrote, I think that the set semantics of our type G is

[[G \alpha]]^set [\alpha := A] = A

Indeed, (Lan_1 1) A = A for every set A. Intuitively this makes sense,
because for every a : A there is a fuction

k_a : 1 > A

and thus an element

map k_a \ast : G A

In particular, [[G 0]]^set = \emptyset.

Still, it is NOT true that its relational interpretation is [[G \alpha]]^rel
[\alpha := R] = R (and indeed the relational interpretation is not fibered
over the set interpretation)!
\end{verbatim}

\section{Conclusion}

The upshot is that we can consider GADTs as data types (i.e., we can
compute the semantics of GADTs) in two ways: just as determined by
their syntax, as when they are represented by their Church encodings,
or as the functorial completion of their syntax, as obtained by
supplying a suitable map construct, when they are represented as
primitive data types. But, either way, GADTs fail to be well-behaved
wrt parametricity. In the first case, GADTs don't have fmaps so their
parametricity properties can't include naturality properties. In the
second case, we still can't get non-naturality consequences of
parametricity. That is, we can't get BOTH the naturality consequences
of parametricity AND the non-naturality consequences of parametricity
at the same time.



\bibliography{gadt-story-references}

\end{document}
